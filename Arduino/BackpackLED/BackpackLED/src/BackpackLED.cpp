/*
 * BackpackLED.cpp
 * 
 * This is the main control code for the controller microprocessor on the
 * backpack. 
 *
 * Created: 4/12/2015 1:39:40 PM
 *  Author: Josh Yu
 */ 


//#include <avr/io.h>
#include "BackpackLED.h"
#include "../lib/Arduino/Arduino.h"
#include "../lib/SparkFun_BLEMate2/SparkFun_BLEMate2.h"    // BLE Library
#include "../lib/Adafruit_GFX/Adafruit_GFX.h"              // Core graphics library
#include "../lib/Adafruit_RGBMatrix/RGBmatrixPanel.h"      // LED hardware library

// Private functions
void initMatrix();
void initBluetooth();
void drawMatrix(int msgNum);

static String fullBuffer = "";
static String inputBuffer;
static String sendBuffer;
boolean central = true;
int counter = 0;
int i = 0;

RGBmatrixPanel matrix(A, B, C, D, CLK, LAT, OE, false);

BLEMate2 BTModu(&Serial1);



int main(void)
{
    setup();
    while(1)
    {
        doCentralExample();
    }
    return 0;
}




void setup()
{
    initMatrix();
    
    Serial.begin(9600);    // This is the Serial-to-PC default baud rate.
    Serial1.begin(9600);    // This is the BC118 default baud rate.

    initBluetooth();
}


void doCentralExample()
{
    // When a remote module connects to us, we'll start to see a bunch of stuff.
    //  Most of that is just overhead; we don't really care about it. All we
    //  *really* care about is data, and data looks like this:
    // RCV=20 char max msg\n\r

    // The state machine for capturing that can be pretty easy: when we've read
    //  in \n\r, check to see if the string began with "RCV=". If yes, do
    //  something. If no, discard it.
    while(1){
        while (!inputBuffer.endsWith("\n\r"))
        {
            inputBuffer.concat((char)Serial1.read());
            //delay(10);
        }
        Serial.println(inputBuffer);
        
        // We'll probably see a lot of lines that end with \n\r- that's the default
        //  line ending for all the connect info messages, for instance. We can
        //  ignore all of them that don't start with "RCV=". Remember to clear your
        //  String object after you find \n\r!!!
//        if (inputBuffer.endsWith("\n\r"))
//        {
        if (inputBuffer.startsWith("RCV="))
        {
            inputBuffer.trim(); // Remove \n\r from end.
            inputBuffer.remove(0,4); // Remove RCV= from front.
            if (inputBuffer == "BL1") 
            {
                drawMatrix(1);
            }
            drawMatrix(inputBuffer.toInt());
        }
//        }
        inputBuffer = "";
    }
    BTModu.disconnect();
    
    delay(500);
    Serial.println("The End!");
    while(1);
}


void initMatrix()
{
    matrix.begin();
    matrix.setCursor(7, 0);
    matrix.setTextSize(1);
    matrix.setTextColor(matrix.Color333(7, 7, 7));
    
    matrix.print("H");
    matrix.print("I");
    matrix.print("!");

    delay(3000);

    matrix.fillRect(0, 0, 31, 31, matrix.Color333(0, 0, 0));
    delay(500);
}

void initBluetooth()
{
    // Regarding function return values: most functions that interact with the
    //  BC118 will return BLEMate2::opResult values. The possible values here
    //  are:
    //  REMOTE_ERROR - No remote devices exist.
    //  INVALID_PARAM - You've called the function with an invalid parameter.
    //  TIMEOUT_ERROR - The BC118 failed to respond to the command in a timely
    //                   manner; timely is redefined for each command.
    //  MODULE_ERROR - The BC118 didn't like the command string it received.
    //                  This will probably only occur when you attempt to send
    //                  commands and parameters outside the built-ins.
    //  SUCCESS - What it says.

    // Reset is a blocking function which gives the BC118 a few seconds to reset.
    //  After a reset, the module will return to whatever settings are in
    //  non-volatile memory. One other *super* important thing it does is issue
    //  the "SCN OFF" command after the reset is completed. Why is this important?
    //  Because if the device is in central mode, it *will* be scanning on reset.
    //  No way to change that. The text traffic generated by the scanning will
    //  interfere with the firmware on the Arduino properly identifying response
    //  strings from the BC118.
    if (BTModu.reset() != BLEMate2::SUCCESS)
    {
        Serial.println("Module reset error!");
        while (1);
    }

    // restore() resets the module to factory defaults; you'll need to perform
    //  a writeConfig() and reset() to make those settings take effect. We don't
    //  do that automatically because there may be things the user wants to
    //  change before committing the settings to non-volatile memory and
    //  resetting.
    if (BTModu.restore() != BLEMate2::SUCCESS)
    {
        Serial.println("Module restore error!");
        while (1);
    }
    // writeConfig() stores the current settings in non-volatile memory, so they
    //  will be in place on the next reboot of the module. Note that some, but
    //  not all, settings changes require a reboot. It's probably in general best
    //  to write/reset when changing anything.
    if (BTModu.writeConfig() != BLEMate2::SUCCESS)
    {
        Serial.println("Module write config error!");
        while (1);
    }
    // One more reset, to make the changes take effect.
    if (BTModu.reset() != BLEMate2::SUCCESS)
    {
        Serial.println("Second module reset error!");
        while (1);
    }

    // NB!!!!!!!!!!!!! This write/reset thing is *really* important.
    //  The status command (STS) and the LEDs *will* lie to you and tell you that
    //  you are e.g. advertising or in central mode when in fact that is not the
    //  case and the module still needs to be reset before that is actually true.

    // Okay, now we're unquestionably set to default settings. That means we're
    //  set up as a peripheral device, advertising forever. You should be seeing
    //  a blinking red LED on the BLE Mate.

    //***************SETUP BLUETOOTH PERIPHERAL**********************
    boolean inCentralMode = false;
    // A word here on amCentral: amCentral's parameter is passed by reference, so
    //  the answer to the question "am I in central mode" is handed back as the
    //  value in the boolean passed to it when it is called. The reason for this
    //  is the allow the user to check the return value and determine if a module
    //  error occurred: should I trust the answer or is there something larger
    //  wrong than merely being in the wrong mode?
    BTModu.amCentral(inCentralMode);
    if (inCentralMode)
    {
        BTModu.BLEPeripheral();
        BTModu.BLEAdvertise();
    }

    // There are a few more advance settings we'll probably, but not definitely,
    //  want to tweak before we reset the device.

    // The CCON parameter will enable advertising immediately after a disconnect.
    BTModu.stdSetParam("CCON", "ON");
    // The ADVP parameter controls the advertising rate. Can be FAST or SLOW.
    BTModu.stdSetParam("ADVP", "FAST");
    // The ADVT parameter controls the timeout before advertising stops. Can be
    //  0 (for never) to 4260 (71min); integer value, in seconds.
    BTModu.stdSetParam("ADVT", "0");
    // The ADDR parameter controls the devices we'll allow to connect to us.
    //  All zeroes is "anyone".
    BTModu.stdSetParam("ADDR", "000000000000");

    BTModu.writeConfig();
    BTModu.reset();
  
    // We're set up to allow anything to connect to us now.
}

void drawMatrix(int msgNum)
{
    switch (msgNum) {
        case 1:
        //turn left

        //draw a left arrow
        //horiz line
        for (i = 0; i < 3; i++) {
            matrix.drawLine(27, 15, 5, 15, matrix.Color333(4, 7, 5));
            matrix.drawLine(16, 4, 6, 14, matrix.Color333(4, 7, 5));
            matrix.drawLine(16, 26, 6, 16, matrix.Color333(4, 7, 5));
            delay(500);
            
            matrix.fillRect(0, 0, 31, 31, matrix.Color333(0, 0, 0));
            delay(500);
        }
        break;
        case 2:
        //turn right
        //draw a right arrow
        //horiz line
        for (i = 0; i < 3; i++) {
            matrix.drawLine(5, 15, 27, 15, matrix.Color333(4, 7, 5));
            matrix.drawLine(16, 4, 26, 14, matrix.Color333(4, 7, 5));
            matrix.drawLine(16, 26, 26, 16, matrix.Color333(4, 7, 5));
            delay(500);
            
            matrix.fillRect(0, 0, 31, 31, matrix.Color333(0, 0, 0));
            delay(500);
        }

        break;
        
        3:
        for (i = 0; i < 3; i++) {
            //draw a stop sign
            matrix.fillCircle(15, 15, 15, matrix.Color333(7, 0, 0));
            
            //STOP text
            matrix.setCursor(4, 12);
            matrix.setTextSize(1);
            matrix.setTextColor(matrix.Color333(0, 0, 0));
            
            matrix.print("S");
            matrix.print("T");
            matrix.print("O");
            matrix.print("P");
            delay(3000);
            
            matrix.fillRect(0, 0, 31, 31, matrix.Color333(0, 0, 0));
            delay(500);
            
        }
        break;
    }
}
