/*
* SensorGloves.cpp
*
* Created: 4/13/2015 12:29:35 AM
*  Author: Jiaxin
*/

#include "SensorGloves.h"
extern "C" {
    #include "blink_leds.h"
}
#include "../lib/Arduino/Arduino.h"
#include "../lib/SparkFun_BLEMate2/SparkFun_BLEMate2.h"
#include <avr/io.h>
#include <util/delay.h>

String fullBuffer;
String inputBuffer;
String sendBuffer;

boolean left_arrow_on;
boolean right_arrow_on;
boolean top_arrow_on;
boolean status_led_on;

BLEMate2 BTModu(&Serial);

#define LEFTTHUMBPIN 0
#define RIGHTTHUMBPIN 0
#define LEFTINDEXPIN 1
#define RIGHTINDEXPIN 1
#define LEFTMIDDLEPIN 2
#define RIGHTMIDDLEPIN 2
#define BPLGHEADER "BL"
#define BPRGHEADER "BR"
#define PLGHEADER "PL"
#define PRGHEADER "PR"

#define LEFTGLOVE
//#define RIGHTGLOVE

int counter = 1;

int turnSignalSent = 0;

#ifdef LEFTGLOVE
int leftThumbReading = 0;
int leftIndexReading = 0;
int leftMiddleReading = 0;
#endif

#ifdef RIGHTGLOVE
int rightFlexReading = 0;
int rightIndexReading = 0;
int rightMiddleReading = 0;
#endif

void setupPeripheralExample();
void do_serial_task();
void do_flex_sensor_read_task();
void do_led_blink_task();


#define SERIAL_READ_TASK_PERIOD 50
#define FLEX_SENSOR_READ_TASK_PERIOD 100
#define LED_BLINK_TASK_PERIOD 200

unsigned long serial_task_last_run = 0;
unsigned long flex_sensor_read_task_last_run = 0;
unsigned long led_blink_task_last_run = 0;


void setup()
{
    init();
    setup_leds();
    
    Serial.begin(9600);           // This is the BC118 default baud rate.

    #ifdef DEBUG
    Serial.println("Serial has started...");
    #endif
    


    // Regarding function return values: most functions that interact with the
    //  BC118 will return BLEMate2::opResult values. The possible values here
    //  are:
    //  REMOTE_ERROR - No remote devices exist.
    //  INVALID_PARAM - You've called the function with an invalid parameter.
    //  TIMEOUT_ERROR - The BC118 failed to respond to the command in a timely
    //                   manner; timely is redefined for each command.
    //  MODULE_ERROR - The BC118 didn't like the command string it received.
    //                  This will probably only occur when you attempt to send
    //                  commands and parameters outside the built-ins.
    //  SUCCESS - What it says.


    boolean firstResetSuccess = false;
    boolean restoreSuccess = false;
    boolean writeConfigSuccess = false;
    boolean secondResetSuccess = false;
    for (int i = 0; i < 10; i++) {
        // Reset is a blocking function which gives the BC118 a few seconds to reset.
        //  After a reset, the module will return to whatever settings are in
        //  non-volatile memory. One other *super* important thing it does is issue
        //  the "SCN OFF" command after the reset is completed. Why is this important?
        //  Because if the device is in central mode, it *will* be scanning on reset.
        //  No way to change that. The text traffic generated by the scanning will
        //  interfere with the firmware on the Arduino properly identifying response
        //  strings from the BC118.
        if (BTModu.reset() == BLEMate2::SUCCESS)
        {
            firstResetSuccess = true;
        } else
        {
            goto setup_try_again;
        }
        // restore() resets the module to factory defaults; you'll need to perform
        //  a writeConfig() and reset() to make those settings take effect. We don't
        //  do that automatically because there may be things the user wants to
        //  change before committing the settings to non-volatile memory and
        //  resetting.
        if (BTModu.restore() == BLEMate2::SUCCESS)
        {
            restoreSuccess = true;
        } else
        {
            goto setup_try_again;
        }
        // writeConfig() stores the current settings in non-volatile memory, so they
        //  will be in place on the next reboot of the module. Note that some, but
        //  not all, settings changes require a reboot. It's probably in general best
        //  to write/reset when changing anything.
        if (BTModu.writeConfig() == BLEMate2::SUCCESS)
        {
            writeConfigSuccess = true;
        } else
        {
            goto setup_try_again;
        }

        // One more reset, to make the changes take effect.
        // NB!!!!!!!!!!!!! This write/reset thing is *really* important.
        //  The status command (STS) and the LEDs *will* lie to you and tell you that
        //  you are e.g. advertising or in central mode when in fact that is not the
        //  case and the module still needs to be reset before that is actually true.
        if (BTModu.reset() == BLEMate2::SUCCESS)
        {
            secondResetSuccess = true;
        } else
        {
            goto setup_try_again;
        }

        setup_try_again:
        //#ifdef DEBUG
        if (!firstResetSuccess) {
            Serial.println("Module reset error!");
            } else if (!restoreSuccess) {
            Serial.println("Module restore error!");
            } else if (!writeConfigSuccess) {
            Serial.println("Module write config error!");
            } else if (!secondResetSuccess) {
            Serial.println("Second module reset error!");
            } else {
            Serial.println("Reset/Restore/Write Config PASSED...");
            break;
        }
        //#endif
    }
    if (!(firstResetSuccess && restoreSuccess && writeConfigSuccess && secondResetSuccess)) {
        // Setup failed after 10 tries
        #ifdef DEBUG
        Serial.println("Reset/Restore/Write Config FAILED 10 TIMES. STOP EXECUTION...");
        #endif
        while(1) {}
    }
    
    #ifdef DEBUG
    Serial.println("Reset/Restore/Write Config DONE!");
    #endif
    delay(1000);
}

int find_text(String needle, String haystack) {
    int foundpos = -1;
    for (unsigned int i = (haystack.length() - needle.length() - 1); (i > 0); i--) {
        if (haystack.substring(i,needle.length()+i) == needle) {
            foundpos = i;
        }
    }
    return foundpos;
}

void loop()
{
    // When a remote module connects to us, we'll start to see a bunch of stuff.
    //  Most of that is just overhead; we don't really care about it. All we
    //  *really* care about is data, and data looks like this:
    // RCV=20 char max msg\n\r

    // The state machine for capturing that can be pretty easy: when we've read
    //  in \n\r, check to see if the string began with "RCV=". If yes, do
    //  something. If no, discard it.

    static unsigned long main_loop_timer;
    main_loop_timer = millis();
    
    if (main_loop_timer > (serial_task_last_run + SERIAL_READ_TASK_PERIOD)) {
        Serial.println("Serial runs");
        do_serial_task();
        
        serial_task_last_run = millis();
    }

    if (main_loop_timer > (flex_sensor_read_task_last_run + FLEX_SENSOR_READ_TASK_PERIOD)) {
        Serial.println("Flex read runs");
        do_flex_sensor_read_task();
        flex_sensor_read_task_last_run = millis();
    }
        

    if (main_loop_timer > (led_blink_task_last_run + LED_BLINK_TASK_PERIOD)) {
        Serial.println("LED blink runs");
        do_led_blink_task();
        led_blink_task_last_run = millis();
    }
}

// The default settings are good enough for the peripheral example; just to
//  be on the safe side, we'll check the amICentral() function and do a r/w/r
//  if we're in central mode instead of peripheral mode.
void setupPeripheralExample()
{
    boolean inCentralMode = false;
    // A word here on amCentral: amCentral's parameter is passed by reference, so
    //  the answer to the question "am I in central mode" is handed back as the
    //  value in the boolean passed to it when it is called. The reason for this
    //  is the allow the user to check the return value and determine if a module
    //  error occurred: should I trust the answer or is there something larger
    //  wrong than merely being in the wrong mode?
    BTModu.amCentral(inCentralMode);
    if (inCentralMode)
    {
        BTModu.BLEPeripheral();
        BTModu.BLEAdvertise();
    }

    // There are a few more advance settings we'll probably, but not definitely,
    //  want to tweak before we reset the device.

    // The CCON parameter will enable advertising immediately after a disconnect.
    BTModu.stdSetParam("CCON", "ON");
    // The ADVP parameter controls the advertising rate. Can be FAST or SLOW.
    BTModu.stdSetParam("ADVP", "FAST");
    // The ADVT parameter controls the timeout before advertising stops. Can be
    //  0 (for never) to 4260 (71min); integer value, in seconds.
    BTModu.stdSetParam("ADVT", "0");
    // The ADDR parameter controls the devices we'll allow to connect to us.
    //  All zeros is "anyone".
    BTModu.stdSetParam("ADDR", "000000000000");

    BTModu.writeConfig();
    BTModu.reset();

    // We're set up to allow anything to connect to us now.
}

void do_serial_task()
{
    boolean done = false;
    while (!done && Serial.available() > 0)
    {
        digitalWrite(11,HIGH);
        inputBuffer.concat((char)Serial.read());
        digitalWrite(11,LOW);
        if (find_text(String("\n\r"), inputBuffer) != -1) {
            done = true;
        }
    }
    // We'll probably see a lot of lines that end with \n\r- that's the default
    //  line ending for all the connect info messages, for instance. We can
    //  ignore all of them that don't start with "RCV=". Remember to clear your
    //  String object after you find \n\r!!!

    int rcv_pos = find_text(String("RCV="), inputBuffer);
    if (rcv_pos == -1) {
        inputBuffer = "";
        } else {
        inputBuffer.remove(rcv_pos,4); // Remove RCV= from front.
        int line_end_pos = find_text(String("\n\r"), inputBuffer);
        inputBuffer.remove((unsigned int)line_end_pos);
        #ifdef DEBUG
        Serial.println(inputBuffer);
        #endif
        

        // what kind of messages go to glove? navigation, ack from backpack,
        // check if the input buffer is intended for the left or right glove
        // check if the message is coming from the phone or backpack
        // then check flex sensors for any special readings for sending to backpack

        //for acknowledgement: if there's already been an acknowledgment for
        
        #ifdef LEFTGLOVE
        if (inputBuffer == "LP1") {
            Serial.println("TO LEFT GLOVE: NAV SAYS LEFT");
            left_arrow_on = true;
            //do some ack stuff here
            Serial.flush();
            sendBuffer.concat(PLGHEADER);
            sendBuffer.concat("1");
            BTModu.sendData(sendBuffer);
            sendBuffer = "";
            } else if (inputBuffer == "LP2") {
            Serial.println("TO LEFT GLOVE: NAV SAYS RIGHT");
            right_arrow_on = true;
            //do some ack stuff here
            Serial.flush();
            sendBuffer.concat(PLGHEADER);
            sendBuffer.concat("2");
            BTModu.sendData(sendBuffer);
            sendBuffer = "";
            } else if (inputBuffer == "LP3") {
            Serial.println("TO LEFT GLOVE: NAV SAYS STRAIGHT");
            top_arrow_on = true;
            //do some ack stuff here
            Serial.flush();
            sendBuffer.concat(PLGHEADER);
            sendBuffer.concat("3");
            BTModu.sendData(sendBuffer);
            sendBuffer = "";
            } else if (inputBuffer == "LB1" || inputBuffer == "LB2" || inputBuffer == "LB3") {
            Serial.println("TO LEFT GLOVE: BACKPACK KNOWS WHAT'S UP");
            status_led_on = true;
            turnSignalSent = 0;
        }
        #endif

        #ifdef RIGHTGLOVE
        if (inputBuffer == "RP1") {
            Serial.println("TO RIGHT GLOVE: NAV SAYS LEFT");
            
            //do some ack stuff here
            Serial.flush();
            sendBuffer.concat(PRGHEADER);
            sendBuffer.concat("1");
            BTModu.sendData(sendBuffer);
            sendBuffer = "";
            } else if (inputBuffer == "RP2") {
            Serial.println("TO RIGHT GLOVE: NAV SAYS RIGHT");
            blink_right_arrow(10);
            //do some ack stuff here
            Serial.flush();
            sendBuffer.concat(PRGHEADER);
            sendBuffer.concat("2");
            BTModu.sendData(sendBuffer);
            sendBuffer = "";
            } else if (inputBuffer == "RP3") {
            Serial.println("TO RIGHT GLOVE: NAV SAYS STRAIGHT");
            blink_top_arrow(10);
            //do some ack stuff here
            Serial.flush();
            sendBuffer.concat(PRGHEADER);
            sendBuffer.concat("3");
            BTModu.sendData(sendBuffer);
            sendBuffer = "";
            } else if (inputBuffer == "RB1" || inputBuffer == "RB2" || inputBuffer == "RB3") {
            Serial.println("TO RIGHT GLOVE: BACKPACK KNOWS WHAT'S UP");
            blink_indicator(10);
            turnSignalSent = 0;
        }
        #endif

        fullBuffer += inputBuffer;
        inputBuffer = "";
        sendBuffer = "";
    }
}

void do_flex_sensor_read_task()
{
    //read them flex sensors here
    #ifdef LEFTGLOVE
    leftThumbReading = analogRead(LEFTTHUMBPIN);
    leftIndexReading = analogRead(LEFTINDEXPIN);
    leftMiddleReading = analogRead(LEFTMIDDLEPIN);
    Serial.println("Right Flex Reading (T, I, M): ");
    Serial.println(leftThumbReading);
    Serial.println(leftIndexReading);
    Serial.println(leftMiddleReading);
    if ((leftThumbReading > 530) && (leftIndexReading > 530) && (leftMiddleReading > 530) && (turnSignalSent == 0)) {
        Serial.flush();
        sendBuffer.concat(BPLGHEADER);
        sendBuffer.concat("1");
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
        turnSignalSent = 1;
    }
    #endif

    #ifdef RIGHTGLOVE
    rightThumbReading = analogRead(RIGHTTHUMBPIN);
    rightIndexReading = analogRead(RIGHTINDEXPIN);
    rightMiddleReading = analogRead(RIGHTMIDDLEPIN);
    Serial.println("Right Flex Reading (T, I, M): ");
    Serial.println(rightThumbReading);
    Serial.println(rightIndexReading);
    Serial.println(rightMiddleReading);
    if ((rightThumbReading > 530) && (rightIndexReading > 530) && (rightMiddleReading > 530) && (turnSignalSent == 0)) {
        Serial.flush();
        sendBuffer.concat(BPRGHEADER);
        sendBuffer.concat("2");
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
        turnSignalSent = 1;
    }
    #endif
}

void do_led_blink_task()
{
    if (left_arrow_on) {
        blink_left_arrow();
    }
    if (right_arrow_on) {
        blink_right_arrow();
    }
    if (top_arrow_on) {
        blink_top_arrow();
    }
    if (status_led_on) {
        blink_status_led();
    }
}