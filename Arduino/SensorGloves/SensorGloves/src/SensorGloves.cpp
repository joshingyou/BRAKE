/*
* SensorGloves.cpp
*
* Created: 4/13/2015 12:29:35 AM
*  Author: Jiaxin
*/

#include "SensorGloves.h"
extern "C" {
    #include "blink_leds.h"
}
#include "../lib/Arduino/Arduino.h"
#include "../lib/SparkFun_BLEMate2/SparkFun_BLEMate2.h"

String inputBuffer;
String sendBuffer;

boolean left_arrow_on = false;
boolean right_arrow_on = false;
boolean top_arrow_on = false;
boolean status_led_on = false;

boolean turn_signal_on = false;
boolean waiting_backpack_ack = false;

boolean gesture_timer_started = false;

BLEMate2 BTModu(&Serial);

#define THUMB_PIN 0
#define INDEX_PIN 1
#define MIDDLE_PIN 2

#define LEFTGLOVE
//#define RIGHTGLOVE

#define GESTURE_LEEWAY 25
#define GESTURE_HOLD_TIME 2000

int thumbReading = 0;
int indexReading = 0;
int middleReading = 0;

#ifdef LEFTGLOVE
#define LEFT_THUMB_STRAIGHT 700
#define LEFT_THUMB_BENT 860
#define LEFT_INDEX_STRAIGHT 475
#define LEFT_INDEX_BENT 715
#define LEFT_MIDDLE_STRAIGHT 525
#define LEFT_MIDDLE_BENT 710
#endif

#ifdef RIGHTGLOVE
#define RIGHT_THUMB_STRAIGHT 725
#define RIGHT_THUMB_BENT 840
#define RIGHT_INDEX_STRAIGHT 500
#define RIGHT_INDEX_BENT 760
#define RIGHT_MIDDLE_STRAIGHT 470
#define RIGHT_MIDDLE_BENT 640
#endif

void setupPeripheralExample();
void do_serial_task();
void do_flex_sensor_read_task();
void do_led_blink_task();


#define SERIAL_READ_TASK_PERIOD 1000
#define FLEX_SENSOR_READ_TASK_PERIOD 500
#define LED_BLINK_TASK_PERIOD 500
#define ACK_TIMEOUT 2000

unsigned long serial_task_last_run = 0;
unsigned long flex_sensor_read_task_last_run = 0;
unsigned long led_blink_task_last_run = 0;
unsigned long glove_send_time = 0;
unsigned long gesture_start_time = 0;


void setup()
{
    setup_leds();
    
    Serial.begin(9600);           // This is the BC118 default baud rate.

    #ifdef DEBUG
    Serial.println("Serial has started...");
    #endif
    


    // Regarding function return values: most functions that interact with the
    //  BC118 will return BLEMate2::opResult values. The possible values here
    //  are:
    //  REMOTE_ERROR - No remote devices exist.
    //  INVALID_PARAM - You've called the function with an invalid parameter.
    //  TIMEOUT_ERROR - The BC118 failed to respond to the command in a timely
    //                   manner; timely is redefined for each command.
    //  MODULE_ERROR - The BC118 didn't like the command string it received.
    //                  This will probably only occur when you attempt to send
    //                  commands and parameters outside the built-ins.
    //  SUCCESS - What it says.


    boolean firstResetSuccess = false;
    boolean restoreSuccess = false;
    boolean writeConfigSuccess = false;
    boolean secondResetSuccess = false;
    for (int i = 0; i < 10; i++) {
        // Reset is a blocking function which gives the BC118 a few seconds to reset.
        //  After a reset, the module will return to whatever settings are in
        //  non-volatile memory. One other *super* important thing it does is issue
        //  the "SCN OFF" command after the reset is completed. Why is this important?
        //  Because if the device is in central mode, it *will* be scanning on reset.
        //  No way to change that. The text traffic generated by the scanning will
        //  interfere with the firmware on the Arduino properly identifying response
        //  strings from the BC118.
        if (BTModu.reset() == BLEMate2::SUCCESS)
        {
            firstResetSuccess = true;
        } else
        {
            goto setup_try_again;
        }
        // restore() resets the module to factory defaults; you'll need to perform
        //  a writeConfig() and reset() to make those settings take effect. We don't
        //  do that automatically because there may be things the user wants to
        //  change before committing the settings to non-volatile memory and
        //  resetting.
        if (BTModu.restore() == BLEMate2::SUCCESS)
        {
            restoreSuccess = true;
        } else
        {
            goto setup_try_again;
        }
        // writeConfig() stores the current settings in non-volatile memory, so they
        //  will be in place on the next reboot of the module. Note that some, but
        //  not all, settings changes require a reboot. It's probably in general best
        //  to write/reset when changing anything.
        if (BTModu.writeConfig() == BLEMate2::SUCCESS)
        {
            writeConfigSuccess = true;
        } else
        {
            goto setup_try_again;
        }

        // One more reset, to make the changes take effect.
        // NB!!!!!!!!!!!!! This write/reset thing is *really* important.
        //  The status command (STS) and the LEDs *will* lie to you and tell you that
        //  you are e.g. advertising or in central mode when in fact that is not the
        //  case and the module still needs to be reset before that is actually true.
        if (BTModu.reset() == BLEMate2::SUCCESS)
        {
            secondResetSuccess = true;
        } else
        {
            goto setup_try_again;
        }

        setup_try_again:
        //#ifdef DEBUG
        if (!firstResetSuccess) {
            Serial.println("Module reset error!");
            } else if (!restoreSuccess) {
            Serial.println("Module restore error!");
            } else if (!writeConfigSuccess) {
            Serial.println("Module write config error!");
            } else if (!secondResetSuccess) {
            Serial.println("Second module reset error!");
            } else {
            Serial.println("Reset/Restore/Write Config PASSED...");
            break;
        }
        //#endif
    }
    if (!(firstResetSuccess && restoreSuccess && writeConfigSuccess && secondResetSuccess)) {
        // Setup failed after 10 tries
        #ifdef DEBUG
        Serial.println("Reset/Restore/Write Config FAILED 10 TIMES. STOP EXECUTION...");
        #endif
        while(1) {}
    }
    
    #ifdef DEBUG
    Serial.println("Reset/Restore/Write Config DONE!");
    #endif
    delay(1000);
}

void loop()
{
    if (millis() > (serial_task_last_run + SERIAL_READ_TASK_PERIOD)) {
        //Serial.println("Serial runs");
        do_serial_task();
        serial_task_last_run = millis();
    }

    if (millis() > (flex_sensor_read_task_last_run + FLEX_SENSOR_READ_TASK_PERIOD)) {
        //Serial.println("Flex read runs");
        do_flex_sensor_read_task();
        flex_sensor_read_task_last_run = millis();
    }
        

    if (millis() > (led_blink_task_last_run + LED_BLINK_TASK_PERIOD)) {
        //Serial.println("LED blink runs");
        do_led_blink_task();
        led_blink_task_last_run = millis();
    }
}

// The default settings are good enough for the peripheral example; just to
//  be on the safe side, we'll check the amICentral() function and do a r/w/r
//  if we're in central mode instead of peripheral mode.
void setupPeripheralExample()
{
    boolean inCentralMode = false;
    // A word here on amCentral: amCentral's parameter is passed by reference, so
    //  the answer to the question "am I in central mode" is handed back as the
    //  value in the boolean passed to it when it is called. The reason for this
    //  is the allow the user to check the return value and determine if a module
    //  error occurred: should I trust the answer or is there something larger
    //  wrong than merely being in the wrong mode?
    BTModu.amCentral(inCentralMode);
    if (inCentralMode)
    {
        BTModu.BLEPeripheral();
        BTModu.BLEAdvertise();
    }

    // There are a few more advance settings we'll probably, but not definitely,
    //  want to tweak before we reset the device.

    // The CCON parameter will enable advertising immediately after a disconnect.
    BTModu.stdSetParam("CCON", "ON");
    // The ADVP parameter controls the advertising rate. Can be FAST or SLOW.
    BTModu.stdSetParam("ADVP", "FAST");
    // The ADVT parameter controls the timeout before advertising stops. Can be
    //  0 (for never) to 4260 (71min); integer value, in seconds.
    BTModu.stdSetParam("ADVT", "0");
    // The ADDR parameter controls the devices we'll allow to connect to us.
    //  All zeros is "anyone".
    BTModu.stdSetParam("ADDR", "000000000000");

    BTModu.writeConfig();
    BTModu.reset();

    // We're set up to allow anything to connect to us now.
}

void do_serial_task()
{
    while (Serial.available() > 0)
    {        
        inputBuffer.concat((char)Serial.read());
        delay(50);
    }

    // When a remote module connects to us, we'll start to see a bunch of stuff.
    // Most of that is just overhead; we don't really care about it. All we
    // *really* care about is data, and data looks like this:
    // RCV=20 char max msg\n\r

    // The state machine for capturing that can be pretty easy: when we've read
    // in \n\r, check to see if the string began with "RCV=". If yes, do
    // something. If no, discard it.

    if (inputBuffer.endsWith("\n\r")) {
        if (inputBuffer.startsWith("RCV=")) {
            inputBuffer.trim();
            inputBuffer.remove(0, 4);
            goto parse_message;
        } else {
            inputBuffer = "";
        }
    } else {
        inputBuffer = "";
    }
    
parse_message:

    // what kind of messages go to glove? navigation, ack from backpack,
    // check if the input buffer is intended for the left or right glove
    // check if the message is coming from the phone or backpack
    // then check flex sensors for any special readings for sending to backpack

    //for acknowledgment: if there's already been an acknowledgment for
        
    #ifdef LEFTGLOVE
    if (inputBuffer.startsWith("LP1")) {
        Serial.println("TO LEFT GLOVE: NAV SAYS LEFT");
        left_arrow_on = true; right_arrow_on = false; top_arrow_on = false;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PL1";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
      
    } else if (inputBuffer.startsWith("LP2")) {
        Serial.println("TO LEFT GLOVE: NAV SAYS RIGHT");
        left_arrow_on = false; right_arrow_on = true; top_arrow_on = false;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PL2";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer.startsWith("LP3")) {
        Serial.println("TO LEFT GLOVE: NAV SAYS STRAIGHT");
        left_arrow_on = false; right_arrow_on = true; top_arrow_on = true;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PL3";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer.startsWith("LP4")) {
        Serial.println("TO LEFT GLOVE: TURN OFF NAV LED");
        left_arrow_on = false; right_arrow_on = false; top_arrow_on = false;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PL4";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer.startsWith("LP5")) {
        waiting_backpack_ack = false;
        turn_signal_on = false;
        left_arrow_on = false; right_arrow_on = false; top_arrow_on = false; status_led_on = false;
        BTModu.disconnect();
        delay(100);
        BTModu.BLEAdvertise();
    } else if (inputBuffer.startsWith("LB1")) {
        /* RECEIVED AN ACK */
        Serial.println("TO LEFT GLOVE: BACKPACK SHOWING LEFT ARROW");
        status_led_on = true;
        waiting_backpack_ack = false;
        turn_signal_on = true;
    } else if (inputBuffer.startsWith("LB4")) {
        /* RECEIVED AN ACK */
        Serial.println("TO LEFT GLOVE: BACKPACK STOPPED SHOWING LEFT ARROW");
        status_led_on = false;
        waiting_backpack_ack = false;
        turn_signal_on = false;
    } 
    #endif

    #ifdef RIGHTGLOVE
    if (inputBuffer == "RP1") {
        Serial.println("TO RIGHT GLOVE: NAV SAYS LEFT");
        left_arrow_on = true; right_arrow_on = false; top_arrow_on = false;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PR1";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer == "RP2") {
        Serial.println("TO RIGHT GLOVE: NAV SAYS RIGHT");
        left_arrow_on = false; right_arrow_on = true; top_arrow_on = false;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PR2";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer == "RP3") {
        Serial.println("TO RIGHT GLOVE: NAV SAYS STRAIGHT");
        left_arrow_on = false; right_arrow_on = false; top_arrow_on = true;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PR3";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer.startsWith("RP4")) {
        Serial.println("TO RIGHT GLOVE: TURN OFF NAV LED");
        left_arrow_on = false; right_arrow_on = false; top_arrow_on = false;
        //do some ack stuff here
        //Serial.flush();
        sendBuffer = "PR4";
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
    } else if (inputBuffer.startsWith("RP5")) {
        waiting_backpack_ack = false;
        turn_signal_on = false;
        left_arrow_on = false; right_arrow_on = false; top_arrow_on = false; status_led_on = false;
        BTModu.disconnect();
        delay(100);
        BTModu.BLEAdvertise();
    } else if (inputBuffer.startsWith("RB2")) {
        /* RECEIVED AN ACK */
        Serial.println("TO RIGHT GLOVE: BACKPACK SHOWING RIGHT ARROW");
        status_led_on = true;
        waiting_backpack_ack = false;
        turn_signal_on = true;
    } else if (inputBuffer.startsWith("RB4")) {
        /* RECEIVED AN ACK */
        Serial.println("TO RIGHT GLOVE: BACKPACK STOPPED SHOWING RIGHT ARROW");
        status_led_on = false;
        waiting_backpack_ack = false;
        turn_signal_on = false;
    } 
    #endif
}

void do_flex_sensor_read_task()
{
    /* GESTURE: Hold index finger out for 2 seconds to toggle on/off turn signal. */
    //read them flex sensors here
    thumbReading = analogRead(THUMB_PIN);
    indexReading = analogRead(INDEX_PIN);
    middleReading = analogRead(MIDDLE_PIN);
    
#ifdef LEFTGLOVE
    if ( (thumbReading > (LEFT_THUMB_BENT - GESTURE_LEEWAY)) && 
         (indexReading < (LEFT_INDEX_STRAIGHT + GESTURE_LEEWAY)) && 
         (middleReading > (LEFT_MIDDLE_BENT - GESTURE_LEEWAY)) )
    {
#endif 
#ifdef RIGHTGLOVE
    if ( (thumbReading > (RIGHT_THUMB_BENT - GESTURE_LEEWAY)) &&
    (indexReading < (RIGHT_INDEX_STRAIGHT + GESTURE_LEEWAY)) &&
    (middleReading > (RIGHT_MIDDLE_BENT - GESTURE_LEEWAY)) )
    {
#endif 
        if (!gesture_timer_started) {
            gesture_timer_started = true;
            gesture_start_time = millis();
        } else {
            if (millis() > (gesture_start_time + GESTURE_HOLD_TIME)) {
                goto send_gesture;
            } else {
                goto dont_send_gesture;
            }
        }
    } else {
        gesture_timer_started = false;
        goto dont_send_gesture;
    }
    
send_gesture:
    if ( (!waiting_backpack_ack) || ( (waiting_backpack_ack) && (millis() > (glove_send_time + ACK_TIMEOUT)) ) ) {
#ifdef LEFTGLOVE
        if (!turn_signal_on) { sendBuffer = "BL1"; }
        else { sendBuffer = "BL4"; }
#endif
#ifdef RIGHTGLOVE
        if (!turn_signal_on) { sendBuffer = "BR2"; }
        else { sendBuffer = "BR4"; }
#endif
        BTModu.sendData(sendBuffer);
        sendBuffer = "";
        gesture_timer_started = false;
        waiting_backpack_ack = true;
        glove_send_time = millis();
    }

dont_send_gesture:
    return;
}

void do_led_blink_task()
{
    if (left_arrow_on) {
        blink_left_arrow();
    } else {
        turn_off_left_arrow();
    }
    
    if (right_arrow_on) {
        blink_right_arrow();
    } else {
        turn_off_right_arrow();
    }
    
    if (top_arrow_on) {
        blink_top_arrow();
    } else {
        turn_off_top_arrow();
    }
    
    if (status_led_on) {
        turn_on_status_led();
    } else {
        turn_off_status_led();
    }
}



/*int find_text(String needle, String haystack) {
    int foundpos = -1;
    for (int i = 0; (i < haystack.length() - needle.length()); i++) {
        if (haystack.substring(i,needle.length()+i) == needle) {
            foundpos = i;
        }
    }
    return foundpos;
}

int reverse_find_text(String needle, String haystack) {
    int foundpos = -1;
    for (int i = (haystack.length() - needle.length()); (i >= 0); i--) {
        if (haystack.substring(i,needle.length()+i) == needle) {
            foundpos = i;
        }
    }
    return foundpos;
}
*/